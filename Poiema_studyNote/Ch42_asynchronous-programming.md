# 비동기 프로그래밍

- Toc

1. [동기식 처리모델과 비동기식 처리모델](#동기식-처리모델과-비동기식-처리모델)
2. [이벤트 루프와 동시성](#이벤트-루프와-동시성)

<br>

<br>

## 동기식 처리모델과 비동기식 처리모델

함수를 호출하면 함수코드가 **평가**되어 함수의 실행컨텍스트가 생성되며 이 때 생성된 함수의 실행컨텍스트는 실행컨텍스트 스택에 push 되고 함수코드의 실행이 완료되면 실행컨텍스트 스택에서 pop 된다.

함수가 실행되려면 함수코드 평가과정에서 생성된 함수 실행컨텍스트가 실행컨텍스트 스택에 **푸시**되어야 한다. 즉, 실행컨텍스트 스택에 함수 실행컨텍스트가 푸시되는 것은 함수의 실행을 의미한다. 이처럼 함수의 실행순서는 실행컨텍스트 스택으로 관리한다.

<strong>자바스크립트엔진은 단 하나의 실행 컨텍스트 스택을 갖는다.</strong> 이는 동시에 2개 이상의 함수를 실행할 수 없다는 것을 의미한다. 실행컨텍스트 스택의 최상위 스택인 현재 실행중인 실행컨텍스트를 제외한 모든 실행 컨텍스트는 모두 실행 대기중인 task들이다. 이러한 task들은 자신의 상위 스택이 모두 pop되면 실행된다.

이처럼 자바스크립트 엔진은 한번에 하나의 task만을 실행할 수 있는 <strong>싱글 스레드(single thread)</strong> 방식으로 동작한다. 싱글스레드 방식은 한번에 하나의 태스크만 실행할 수 있기 때문에 처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹이 발생한다.

```js
function sleep(func, delay) {
    const delayUntil = Date.now() + delay;
    
    while (Date.now() < delayUntil);
    func();
}

function foo() {
    console.log('foo');
}

function bar() {
    console.log('bar');
}

sleep(foo, 3 * 1000);
bar(); // (3초 경과후) foo -> bar
```

위예제에서 bar 함수의 호출은 sleep 함수 내부의 콜백함수인 foo 함수의 호출이 완료된 이후 실행된다. 이처럼 현재 실행중인 task가 종료할 때까지 다음 실행될 task가 대기하는 방식을 <strong>동기식 처리모델(asynchronous processing model)</strong>이라 한다.

동기식 처리모델은 태스크를 순서대로 실행하므로 처리**순서**가 보장된다는 장저이 있지만 앞선 task가 종료될 때까지 이후 task들의 실행이 유보되는 **블로킹**이 발생하는 단점이 있다. 

```js
function foo() {
    console.log('foo');
}

function bar() {
    console.log('bar');
}

setTimeout(foo, 3 * 1000);
bar() // bar -> (3초 경과후) foo
```

타이머함수 setTimeout은 앞서 살펴본 sleep 함수와 유사하게 일정시간이 경과한 이후에 콜백함수를 호출하지만 setTimeout 이후의 task를 <strong>블로킹하지 않고 곧바로 실행</strong>한다. 이처럼 현재 실행중인 task가 종료되지 않은 상태라 하더라도 다음 task를 곧바로 실행하는 방식을 <strong>비동기식 처리모델(asynchronous processing model)</strong>이라 한다.

비동기식 처리모델은 블로킹이 발생하지 않는다는 장점이 있지만 task의 처리순서가 보장되지 않는 단점이 있다.

타이머함수 <strong>setTimeout / setInterval 과 HTTP 요청</strong>은 비동기식 처리모델로 동작한다. 비동기식 처리모델은 자바스크립트의 동시성(concurrency)을 부여한다. 동시성은 이벤트 루프로 구현된다.

<br>

## 이벤트 루프와 동시성

자바스크립트는 싱글스레드로 동작하지만 동시에 처리되는 task들도 많다. 이러한 자바스크립트의 동시성을 지원하는 것이 <strong>이벤트 루프(event loop)</strong>이다.

![image](https://user-images.githubusercontent.com/62285872/83746202-baa7fd00-a699-11ea-82c1-5cc825ef362c.png)

- 콜스택(call stack, 실행 컨텍스트 스택)

소스코드(전역코드, 함수코드, eval코드, 모듈코드)의 평가에 의해 생성된 실행컨텍스트가 push / pop되는 스택형 자료구조인 실행컨텍스트 스택을 의미한다. 함수를 호출하면 함수실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 실행된다. 자바스크립트 엔진은 단 하나의 콜스택을 사용하기 때문에 최상위 실행컨텍스트가 종료되어 콜 스택에서 제거되기 이전까지는 다른 어떤 태스크도 수행되지 않는다.

- 힙(heap)

할당해야 할 메모리 공간의 크기를 런타임에 결정해야하는 객체가 저장되는 메모리 공간으로 구조화되어있지 않다. 콜스택의 요소는 힙에 저장된 객체를 참조한다.

<br>

자바스크립트 엔진은 단순히 task가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행만 할 뿐이다. 동시성을 지원하기 위해 필요한 비동기 요청처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 혹은 Node.js가 담당한다. 이를위해 <strong>브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다.</strong>

- 태스크 큐(task queue / event queue / callback queue)

타이머 함수인 setTimeout 혹은 setInterval과 같은 <strong>비동기 처리함수의 콜백함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다.</strong>

- 이벤트 루프(event loop)

콜 스택에 현재 실행중인 실행 컨텍스트가 있는지 그리고 태스크 큐에 대기중인 함수(콜백함수/ 이벤트 핸들러 등등)가 있는지 반복해서 확인한다. 콜 스택이 비어졌을 때 태스크 큐에서 대기중인 함수는 이벤트 루프에 의해 순차적(FIFO)으로 콜스택으로 이동되어 실행된다. 즉, 태스크 큐에 일시 보관된 함수들은 비동기식 처리모델로 동작한다.

<br>

자바스크립트는 한번에 하나의 일만 처리할 수 있는 싱글스레드 방식으로 동작하지만 브라우저는 아니다. 자바스크립트의 모든 **코드**가 싱글스레드 방식으로 동작한다면 자바스크립트에서 비동기식 동작은 불가능하다.

브라우저는 자바스크립트엔진 이외에도 **렌더링엔진**과 **Web API** 를 제공한다. web api는 ECMAScript 사양에 정의된 함수가 아니라 브라우저에서 제공하는 API이며 DOM API / 타이머 함수 / HTTP 요청과 같은 비동기 처리를 포함한다.