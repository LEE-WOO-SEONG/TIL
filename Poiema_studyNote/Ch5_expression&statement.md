# Expression & Statement

- Toc

1. [Value(값)](#value(값))
2. [Literal(리터럴)](#literal(리터럴))
3. [Expression(표현식)](#expression(표현식))
4. [Statement(문)](#statement(문))
5. [Meaning of Semicolon](#meaning-of-semicolon)
6. [Statement of Expression & NonExpression (표현식인 문과 아닌 문)](#statement-of-expression-&-nonexpression-(표현식인-문과-아닌-문))

<br>

<br>

## Value(값)

값이란 **식**이 **평가**되어 생성된 **결과**이다. => 메모리에 저장될 수 있는 것.

<br>

- 모든 값은 데이터 타입을 가진다.(숫자,문자,객체 등등..)

- 저장된 메모리 '값'은 데이터 타입에 따라 다르게 해석된다. ex)2진수의 형태로 메모리에 저장된 값인 01000001은 숫자타입에서는 65를 의미하지만 문자타입에서는 "A"를 의미한다.

- 변수에 할당되는 것은 '값'이다.

  (앞장에서 변수란 **하나의 값**을 저장하기 위해 확보한 메모리 공간자체 혹은 그 메모리공간을 식별하기 위해 붙인 이름이라고 정의하였다. 그렇기 떄문에 변수에 할당되는것은 '값' 이란 데이터다.)

- 변수혹은 다른 선언에 할당되는 모든 값은 할당되기 이전에 평가되어 결과값을 생성해야 한다. 

<br>

## Literal(리터럴)

리터럴이란 **사람이 이해할 수 있는 문자 또는 약속된 기호**를 사용하여 **값을 생성**!하는 표기방식이다.

<br>

- 자바스크립트 엔진이 리터럴을 '평가' 하여 특정 숫자 혹은 문자와 같은 값을 생성한다

Q) 그렇다면 여기서의 평가는 변수에서 다뤘던 자바스크립트 실행 전 평가와는 다른 의미인가?

<details>
    <summary>그렇다.</summary> 
앞서 변수에서 호이스팅 개념을 설명할 때는 자바스크립엔진의 구동방식이 평가(선언문을 미리 인식하는 과정) + 실행으로 이루어져 있다는 것을 언급한 것이고, 이 대목에서 말하는 '평가'는 리터럴이 <strong>값</strong>으로 생성되어지는 과정중의 '평가'를 말하는 것으로 위 두가지에서 언급되는 '평가'라는 개념은 서로 다른의미를 지닌다.
</details>

- 자바스크립트 엔진은 코드가 **실행되는 시점**(런타임, 즉 실행단계)에 리터럴을 평가하여 값을 생성한다.

Q) 앞서 값이 특정 변수에 할당되기 이전에 평가되어져 생성되어져야 한다고 언급하였다. 그렇다면 값이 할당되는 순서는 자바스크립트 엔진실행 -> 리터럴이 값으로 평가되어 생성됨 -> 변수에 할당 이 맞는가?



<br>

## Expression(표현식)

표현식은 **값**으로 **평가**될 수 있는 **문**(statement)이다. 표현식이 평가되면 값을 생성하거나 참조한다.

<br>

- 리터럴은 값을 생성하는 표기방식으로 값으로 평가되기에 그자체로 표현식이다.

- 값을 참조할 수 있는 식별자 또한 값으로 평가될 수 있기에 표현식이다. ex> var a 에서 a

- 리터럴과 연산자로 이루어져 있는 식은 값으로 평가될 수 있기에 표현식이다. ex) 10 + 20

- 값과 표현식은 동치(equivalent)이다.

  (표현식은 값으로 평가될 수 있기에 1+2 = 3 에서 1+2 라는 표현식은 3이라는 값과 연산자(=)에 의해 동치관계에 놓여진다. 결론적으로 표현식과 값은 동치, 즉 같은것이다. )

- 값과 표현식은 동치이기 때문에 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다.

```javascript
var x = 1 + 2          // x라는 식별자는 표현식,3은 값 /1+2는 3이라는 값으로 평가될 수 있는 표현식

x + 3;                 // +는 산술연산자로 연산을 위해서는 좌항과 우항에는 '값'이 있어야 한다.
					   // x는 표현식이며 값과 동치이다. 그렇기 때문에 값이 오는 자리에 올 수 있다.
```

<br>

## Statement(문)

문(statement)은 프로그램을 구성하는 **기본단위**이자 **최.소.실.행 단위**이다.

<br>

- 토큰의 집합 -> 문
- 문의 집합 -> 프로그램
- 문은 (명령)문이다. (컴퓨터에게 작업실행을 명령하는 문이다.)
- 문에는 선언(명령)문, 할당(명령)문, 조건(명령)문, 반복(명령)문 등으로 구분할 수 있다.

```javascript
// 변수 선언문
var x;

// 표현식 문(할당문)
x = 5;

// 함수 선언문
function foo() {}

// 조건문
if(x>1) {
	console.log(x);
}

// 반복문
for (var i=0; i<2; i++) {
	console.log(i);	
}
```

<br>

##### what is token ?

**문법적 의미**를 가지며 **더이상 나눌 수 없는** 코드의 기본요소 이다.

![image](https://user-images.githubusercontent.com/62285872/79930310-2421d280-8483-11ea-9b6e-aeedc15c0bb7.png)	

<br>

## Meaning of Semicolon 

문이 종료될 때는 세미콜론(;)을 표시한다.

<br>

- 코드블럭`{}`을 사용하는 문(반복문/조건문/함수)은 문의 종료를 의미하는 자체종결성(self closing)을 갖기 때문에 해당 문들의 끝에는 세미콜론의 생략이 가능하다.

- 자바스크립트 엔진은 세미콜론 자동삽입 기능이 내장되어 있어 자체 세미콜론 삽입이 가능하다.

  (이 때문에 어떤경우에는 세미콜론이 없어도 문법적 오류가 발생하지 않음.)

- 세미콜론 자동삽입 기능이 있으나, 해당 기능이 개발자의 의도와는 다른 형태로 적용될 수 있기 때문에 세미콜론을 사용하는 습관을 들이는 것이 바람직하다고 생각한다.

```javascript
function foo () {
  return {}
  // ASI의 동작 결과 => return; {};
  // 개발자의 예측 => return {};
}

console.log(foo()); // undefined

var bar = function () {}
(function() {})();
// ASI의 동작 결과 => var bar = function () {}(function() {})();
// 개발자의 예측 => var bar = function () {}; (function() {})();
// TypeError: (intermediate value)(...) is not a function
```

<br>

## Statement of Expression & NonExpression (표현식인 문과 아닌 문)

표현식은 문의 일부일 수 있으며 그 자체로 문이 될 수도 있다.

<br>

- 표현식인 문: **값**으로 평가될 수 **있는** 문.
- 표현식이 아닌 문 : **값**으로 평가될 수 **없는** 문.

- 앞서 변수에는 값을 할당한다고 언급하였다. 그렇다면 표현식인 문과 아닌문을 구별하는 방법의 하나로 변수에 할당 해 보는 방법이 있다. 할당이된다면 값이 되므로 표현식이고 그 반대는 표현식이 아닌 것이다.
- 할당문은 그 자체로 표현식이며 완전한 문이다. (표현식인 문)

```javascript
var x = 100;                 // 변수선언문이며 표현식이 아닌 문이다.
var z = x = 200;             // z라는 식별자를 가진 변수 선언문 + x = 200의 값을 할당하는 재 할당								  문. 할당문은 표현식인 문으로 변수에 할당이 가능하다.

console.log(z);              -> 200
```



### 완료값

표현식이 아닌 문은 언제나 undefined라는 값을 출력한다. 이는 실제로 해당 문의 결과값이 undefined라는 것은 아니다. 표현식이 아닌 문은 값으로 평가되어질 수 없기 때문에 undefined라는 **완료값**을 가질 뿐인 것이다.

이러한 완료값은 변수에 할당할 수 없고 참조 또한 불가능하다.