# 원시값과 객체의 비교

- Toc

1. [원시타입과 객체타입의 차이](#원시타입과-객체타입의-차이)

2. [원시값](#원시값)

   2-1.[변경 불가능한 값](#변경-불가능한-값)

   2-2.[문자열과 불변성](#문자열과-불변성)

   2-3.[값에 의한 전달](#값에-의한-전달)

3. [객체](#객체)

   3-1.[변경 가능한 값](#변경-가능한-값)

   3-2.[참조에 의한 전달](#참조에-의한-전달)

<br>

<br>

## 원시타입과 객체타입의 차이

- 원시타입은 변경이 불가능한 값이다. (immutable value) 이에비해 객체(참조) 타입의 값은 변경이 가능한 값이다. (mutable)
- 원시값을 변수에 할당하면 변수에는 **실제값**이 저장된다. 객체를 변수에 할당하면 변수에는 **참조값** 이 저장된다.
- 원시값을 갖는 변수를 다른변수에 할당하면 원본의 **원시 값**이 복사되어 전달된다. 이를 값에 의한 전달이라 한다. 객체의 변수를 다른변수에 할당하면 원본의 **참조값**이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.

<br>

## 원시값

### 변경 불가능한 값

원시타입(primitive type)의 값은 변경이 불가능하다. 즉, 한번 생성된 원시값은 read only한 값이므로 변경할 수 없다.

> Q) 값의 변경이 불가능하다는 것은 무슨말인가?
>
> 값을 변경할 수 없다는 것은 재할당을 할 수 없다는 것과는 다른말이다. 만약 원시값을 할당했던 변수에 새로운 원시 값을 재할당하게 되면 기존 메모리 공간에 저장되어 있는 원시값을 바꾸는 것이 아니라 새로운 메모리 공간을 확보하여 그 공간에 값을 할당한 후 변수는 새롭게 확보한 메모리 공간을 가리키는 것이다. 이렇게 되면 이전의 변수가 참조하던 메모리 공간의 주소는 바뀌게 된다.

- 값의 변경이 불가능한 경우(원시타입)

![image-20200427212530814](C:\Users\112606\AppData\Roaming\Typora\typora-user-images\image-20200427212530814.png)	

- 값의 변경이 가능한 경우

  ![image-20200427212743019](C:\Users\112606\AppData\Roaming\Typora\typora-user-images\image-20200427212743019.png)	

  <br>

### 문자열과 불변성

원시 값의 하나인 문자열은 다른 원시값과는 다른 독특한 특징을 가지고 있다. 문자열은 0개 이상의 문자들로 이루어진 집합을 말하는데, 이 때 문자 하나를 저장하기 위해서는 2byte의 메모리 공간이 필요하다.

따라서 문자열은 몇개의 문자로 이루어졌는지에 따라 필요한 메모리공간의 크기가 결정된다. 숫자값은 1, 100 , 10000 모두 동일한 8byte에 저장되지만 문자열은 그렇지 않은 것이다.

> 문자열은 유사배열 객체이다?
>
> 유사배열이란 마치 배열처럼 index로 property 값에 접근이 가능하며 length property를 갖는 객체를 말한다. 문자열은 배열처럼 index를 통해 각 문자에 접근할 수 있으며 length property를 갖는다. 이러한 특성으로 for문에서도 사용이 가능하다.
>
> 자바스크립트에서 문자열은 원시타입으로 정의했는데 유사배열 **객체**라고 표현하면 혼란스러울 수 있겠으나 이는 21장에서 깊숙히 다루도록 하겠다. 
>
> 만약 원시값을 객체로 사용한다면 원시값을 감싸는 래퍼 객체로 자동 변환된다.

```javascript
var str = 'string';

console.log(str[0]);  // s
console.log(str[1]);  // t
console.log(str[2]);  // r
console.log(str[3]);  // i
console.log(str[4]);  // n
console.log(str[5]);  // g

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다.
// 하지만 문자열은 원시 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
str[0] = 'S';

console.log(str); // string
```

위의 예제를 보면 str[0] = 'S' 를 통해 문자열의 특정 index에 접근하지만 그 값은 바뀌지 않는다. 문자열은 원시타입으로 변경이 불가능한 값이기 때문이다. 

하지만 그렇다고 해서 해당 코드가 error가 나는 것은 아니다. 문자열은 원시타입인 동시에 유사 배열 객체로 해당 접근방식이 가능하기 때문이다.

**결론적으로 유사 배열 객체이기 때문에 index를 통해 문자열에 접근이 가능하지만, 원시타입이기 때문에 그 값의 변경은 불가능한 것이다.**

<br>

### 값에 의한 전달

```javascript
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy);  // 80

score = 100;

console.log(score); // 100
console.log(copy);  // ?
```

위 예제에서 copy의 값은 몇이라고 생각하는가?

답은 80이다. 

새로운 변수에 원시값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시값이 **복사**되어 새롭게 할당된다. 기존 변수가 가리키던 공간을 동일하게 가리키는 것이 아니라 똑같은 값을 그대로 복사하여 다른 메모리공간에 갖게되는 것이다. 그렇기 때문에 위 예제의 값은 100이 아닌 80이 되며, 이를 **값에 의한 전달**이라 한다.

![image-20200427214735119](C:\Users\112606\AppData\Roaming\Typora\typora-user-images\image-20200427214735119.png)	

하지만 위의 설명했던 바와는 다르게 새로운 변수에 원시값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 메모리공간에 있는 원시값을 참조하다가, 어느 한쪽의 변수에 재 할당이 이루어졌을 때 비로소 새로운 메모리 공간에 재 할당된 값을 저장하도록 동작할 수도 있다.

![image-20200427215039355](C:\Users\112606\AppData\Roaming\Typora\typora-user-images\image-20200427215039355.png)		

즉, 자바스크립트에서 변수할당에 의한 변수 값의 전달은 2가지 방식으로 해석이 가능하다.

1. 새로운 80을 생성(복사)하여 메모리 주소를 전달하는 방식. 이 방식은 할당 시점에 두 변수가 기억하는 메모리의 주소가 **다르다**
2. 기존 변수가 참조하는 메모리 공간의 주소를 그대로 전달하는 방식. 이 방식은 할당 시점에 두 변수가 기억하는 메모리의 주소가 **같다**

>  하지만 중요한 것은 변수에 원시값을 갖는 변수를 할당하는 경우, 1번 방식이든 / 2번 방식이든 변수에 값을 재 할당하게 되면 결국은 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 된다는 것이다.

<br>

## 객체

객체는 property 개수가 정해져 있지 않고 동적으로 추가 혹은 삭제가 가능하다. 또한 자바스크립트에서 사용할 수 있는 모든 '값'은 프로퍼티가 될 수 있다. 따라서 객체는 원시값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

데이터 타입마다 메모리 공간의 크기를 지정하는 원시타입과 달리 객체타입은 그 경우에 따라 크기가 가변적일 수 있다.

> 자바스크립트와 타 언어의 차이?
>
> java, C++과 같은 **클래스 기반 객체지향 프로그래밍 언어**는 사전에 정의된 클래스에 기반하여 객체(인스턴스)를 생성한다. 즉, 객체를 생성하기 이전에 이미 property와 method가 정해져 있으며 그대로 객체르 실행하는 것이다. 객체가 생성된 이후에는 property를 삭제하거나 추가할 수 없다.
>
> 반면, 자바스크립트는 클래스없이 객체의 생성이 가능하며 객체가 생성된 이후에도 동적으로 property와 method의 추가가 가능하다.

<br>

### 변경 가능한 값

객체(참조)타입의 값, 즉 객체는 변경이 가능한 값이다. 

하기와 같이 객체를 변수에 할당하였다고 가정 해 보자.

```javascript
var person = {
  name: 'Lee'
};
```

원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하게 되면 원시값에 직접 접근이 가능하다. **즉, 원시값을 할당한 변수는 원시 값 자체를 값으로 갖는다.**

하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하게 되면 **참조값**에 접근할 수 있다. 참조값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체이다.

![image-20200427221557253](C:\Users\112606\AppData\Roaming\Typora\typora-user-images\image-20200427221557253.png)		

그렇기 때문에 "변수는 00의 값을 갖는다" 라고 표현하는 원시 값과 다르게 객체값은 "변수는 객체를 **참조**하고 있다 혹은 객체를 가리키고 있다" 라고 표현한다.

앞서 말했던 것처럼 객체는 변경이 가능한 값이기 때문에 객체를 할당한 변수는 **재할당없이** 객체를 직접 변경할 수 있다. 

```javascript
var person = {
  name: 'Lee'
};

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 생성
person.gender = 'male';

console.log(person); // {name: "Kim", gender: "male"}
```

![image-20200427222812382](C:\Users\112606\AppData\Roaming\Typora\typora-user-images\image-20200427222812382.png)	

> 얕은복사(shallow copy)와 깊은복사(deep copy)
>
> 객체를 property 값으로 갖는 객체의 경우 얕은복사는 한 단계 까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.
>
> 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다. 즉, 원본과 복사본은 참조값이 다른 별개의 객체이다. 하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우, 참조값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하여 원시 값처럼 완전한 복사본을 만든다는 차이가 있다.?? => 이말만으로는 아직 완벽히 이해가 되지 않는다.. ㅠ

> Q) 객체의 구조적 단점에 따른 부작용??
>
> 원시값과 다르게 여러개의 식별자가 하나의 객체를 공유할 수 있는 점? 흠..
>
> -> 이것역시 잘 모르겠따..

<br>

### 참조에 의한 전달

```javascript
var person = {
  name: 'Lee'
};

var copy = person;
```

객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조값**이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.

![image-20200427224406958](C:\Users\112606\AppData\Roaming\Typora\typora-user-images\image-20200427224406958.png)	

 그림처럼 원본 person를 사본 copy에 할당하면 원본 person의 참조 값을 복사하여 copy에 저장한다. 이때 원본 person와 사본 copy는 메모리 주소는 다르지만 동일한 참조 값을 갖는다. 다시 말해, 원본 person와 사본 copy 모두 동일한 객체를 가리키고 있다. 이것은 두개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 어떤 한쪽에서 **객체를 변경**(변수에 새로운 객체를 재할당하는 것이 아니라 객체의 프로퍼티 값 변경 또는 추가, 삭제)하면 **서로 영향을 주고 받는다.**

```javascript
var person = {
  name: 'Lee'
};

// 참조 값을 복사. copy와 person은 동일한 참조 값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person을 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리키고 있다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);   // {name: "Kim", address: "Seoul"}
```

결국 **값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사하여 전달한다는 면에서 동일하다.** 다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값인지 참조 값인지의 차이만 있을 뿐이다. 따라서 **자바스크립트에는 참조에 의한 전달은 존재하지 않고 값에 의한 전달만이 존재한다고 말할 수 있다.**