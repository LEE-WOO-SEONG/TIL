# 변수

1. [변수의 정의](#변수의-정의)
2. [변수](#변수)
3. [식별자](#식별자)
4. [할당](#할당)
5. [변수선언](#변수선언)
6. [호이스팅](#호이스팅)

<hr></hr>

<br>

<br>

### 변수의 정의

- [변수](https://ko.wikipedia.org/wiki/변수_(수학))(變數, variable)는 수학에서 쓰이는 수식에 따라서 변하는 값을 뜻한다.
- [변수](https://ko.wikipedia.org/wiki/변수_(컴퓨터_과학))(variable)는 컴퓨터 프로그래밍에서 아직 알려지지 않거나 어느 정도까지만 알려져 있는 양이나 정보에 대한 상징적인 이름이다.
- [변수](https://ko.wikipedia.org/wiki/변수_(1447년))(邊修, 1447년 ~ 1524년)는 조선 중기의 무신이다.
- [변수](https://ko.wikipedia.org/wiki/변수_(1861년))(邊燧, 1861년 ~ 1891년)는 조선 말기의 관료이다.
- [변인](https://ko.wikipedia.org/wiki/변인)(variable) 또는 변수는 실험에서 관측 대상(종속 변인)과 조작 대상(독립 변인)을 말한다.

출처 : <a href="https://ko.wikipedia.org/wiki/변수">위키피디아</a>

<br>

### 변수

<hr></hr>

그동안 내가 알고 있었던 변수란 개념은 수학에서 쓰이는 <s>변하는 값</s> 이였다.

하지만, 프로그래밍에서의 변수는 어떠한 양, 정보에대한 **상징적인 이름**을 뜻한다.

```
10 + 20
```

위 연산을 보면 사람은 당연히 10과 20의 더하기로 알아보지만 컴퓨터는 그렇지 않다.  컴퓨터는 10,20이라는 숫자를 이진법의 형태로 어딘가에 기억하고 + 가 덧셈이라는 것 또한 인지해야 한다.



>  컴퓨터에게 **기억한다**는 것은 무슨 의미일까?

그것은 메모리 공간의 어느한켠에 해당 값을 가지고 있어야 하는 것이다. 

위 결과를 연산하기위해서 컴퓨터는 10 과 20이라는 숫자를 이진법의 형태로 메모리 어느 공간에 **저장**한다.

이후 연산 시 해당 메모리를 값을 불러와 "30"이라는 결과값을 도출하고 해당 결과값 또한 메모리의 어딘가에 저장된다.

이렇게 "10" "20 "30" 이라는 값은 메모리에 저장되어져 있다. 하지만, 어디에 저장되어져 있는지에 대한 정보가 없기 때문에 해당 값들을 다시 불러오려면 메모리 주소에 직접 접근해야 한다.

하지만 메모리 주소에 직접 접근하는 것은 OS의 사용값을 변경할 수도 있으며 또한, 메모리의 주소값은 코드실행 시마다 임의로 결정되는 값이다. 따라서 메모리주소에 직접 접근하지 않고 해당 변수가 저장되어져 있는 메모리 장소를 찾는 방법이 필요하다.



이때, 사용하는 것이 **변수** 이다.

앞서 변수를 상징적인 이름으로 정의 했던 것처럼, 변수는 특정 값이 저장되어져 있는 메모리공간 혹은 그 공간을 지칭하기 위한 이름이다.

만약, 한번사용하고 재사용 필요가 없으면 변수로 표현하지 않아도 되나, 2회이상 사용할 것이라면 변수에 담아 해당정보의 위치를 기억해 놓는 것이 좋다.

<br>

### 식별자와 할당

```
Var result = 30;
```

일반적으로 자바스크립트에서는 Var를 이용하여 변수를 나타낸다.

위 식은 30이라는 값을 `result`라는 이름을 가진 변수로 표현 해 놓은 것이다.

우리는 Var result라는 변수를 통해 30이 저장되어져 있는 공간을 설정하고 `result`라는 변수의 이름으로 이것을 지칭한다. 이렇게 변수의 이름을 나타내는 것을 `식별자(identifier)` 라고 하며 30과 같이 해당 변수에 지정된 값을 `변수값` 이라 한다.

또한, 특정 변수에 특정 값을 담아놓는 것을 `할당 (assignment)` 이라하며, 이러한 변수값을 읽어드리는 것을 `참조(reference)`라 한다.

<br>

### 식별자

<hr></hr>

- 변수 이름을 나타내는 식별자는 개발자가 알아보기 쉽도록 사람이 이해할 수 있는 언어로 값이 저장된 메모리 공간에 붙인 상징적인 이름이다. 

- 때문에 식별자는 변수에 저장된 값의 의미를 명확히 할 수 있는 이름이여야 한다.
- 식별자는 특정 네이밍 규칙을 지니고 있다.



###### 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자/ 숫자 / _ / $기호를 포함할 수 있다.

- 단, 식별자의 시작이 숫자이면 안된다.

- 예약어는 식별자로 사용할 수 없다.

   (예약어란, 프로그래밍 언어에서 이미 사용되고 있거나 앞으로 사용예정인 단어들로 이미 변수선언시 사용된 식별자 또는 함수/객체명이나 함수/배열/객체등에 사용되어지는 특성의 이름을 의미한다.)

- 하나의 변수선언 시 하나의 식별자 이름이 권장된다.

- 되도록 알파벳 이외의 언어를 사용하여 식별자를 나타내지 않는다.
- 식별자는 대소문자를 구별하여 각각 별개로 인식한다 ex) firstname <-> firstName은 다른식별자이다.

- 식별자를 보고 어떤 변수값을 의미하는지를 알 수 있을정도로 명확히 명명한다.(주석이 있어야 뜻을 알 수 있는 식별자는 좋은 식별자가 아니다.)



###### 식별자 네이밍 컨벤션

1. 카멜 케이스 (camelCase) 

```
var firstName;
```

2. 스네이크 케이스 (snake_case)

```
var first_name;
```

3. 파스칼 케이스 (PasacalCase)

```
var FirstName;
```

4. 헝가리언 케이스 (typeHungarianCase)

```
var strFirstName;            // 변수 type + identifier
var $elem = $('.myClass');
```

식별자 컨벤션 네이밍은 상기와 같이 4가지 규칙을 따르나 일반적으로 **변수, 함수에는 카멜케이스**를 / **생성자함수 클래스의 이름에는 파스칼 케이스**를 사용한다.

<br>

### 할당

<hr></hr>

식별자를 가진 변수에 특정 값을 담는 것 혹은 등치시키는 것을 할당이라 한다.

변수에 값을 할당 시 할당연산자(=)를 사용한다. 할당연산자의 우변에 할당할 값을, 좌변에는 변수를 배치한다.

```
var a;          // 변수 선언
a = 1;          // 값 할당

// 단축문
var a = 1;      // 변수 선언 및 값 할당
```



- 할당의 특성

1. 단축문을 자바스크립트 엔진에서는 변수선언과 값의 할당을 완전히 구분하여 실행한다. 

2. **호이스팅 현상에 의해 값의 선언은 런타임(실행단계)이전에 실행되지만 값의 할당은 런타임에서 일어나게 된다.**

3. 선언과 할당이란 초기 변수는 undefined로 먼저 할당이 된 상태에서 특정값이 **"재할당"**되는 개념.

4. 재할당 시, undefined가 저장된 값에 특정값이 할당되는것이 아니라 새로운 공간에 할당되는 것이다.



- garbage collector

애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더이상 사용되지 않고있는(어떠한 식별자도 할당되어져 있지 않은) 메모리를 해제하는 역할을 한다.

자바스크립트는 garbage collector 가 내장되어져 있어 메모리 누수를 방지한다.



- managed language? unmanaged language?

메모리 관리방식에 의해 프로그래밍 언어를 나누어 부르는 개념으로, 개발자가 주도적으로 메모리의 생성/삭제를 관리하면 unmaged language이며, 자바스크립트와 같이 메모리관리를 해당 언어가 관리하면 managed language라 일컫는다.

<br>

### 변수선언

<hr></hr>

변수를 **생성** 하는것으로 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

변수선언이란, 값을 저장하기 위한 메모리 공간을 확보하고 변수이름과 확보된 메모리 공간의 주소를 연결(binding)하여 값을 저장할 수 있도록 **준비**하는 것이라 할 수 있다.  



- 변수 : var, let, const

: ES5까지 자바스크립트에서 변수선언방식은 `var` 한가지였다. 하지만 ES6문법으로 오면서 var가진 문제점을 보완한`let`과 `const`라는 변수선언 방식이 추가되었다.



- var의 문제점

1. 함수레벨 스코프
2. 호이스팅

여기서 var/let/const와 같은 것들을 `키워드`라 하는데,  키워드(keywords)란 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 **수행할 동작을 규정**한 일종의 명령어이다.

예를들면 var, let ,const 뒤에 나오는 이름을 변수의 식별자로 인식하고, 함수뒤에 나오는 이름을 함수의 식별자로 인지한다. 



- 자바스크립트 엔진의 변수선언 방식

1. 선언 단계(Declaration phase) : 변수이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알리는 과정.

2. 초기화 단계(Initialization phase) : 값을 저장하기 위한 메모리 공간을 확보하고 undefined를 할당하는 과정.

   

이렇게 변수가 선언되면 변수이름을 비롯한 모든 식별자는 **실행콘텍스트(execution context)**에 등록되어 자바스크립트 엔진에 의해 관리될 수 있도록 변수의 존재가 알려지게 된다.

<u>여기서 실행 콘텍스트란, 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행결과를 실제로 관리하는 영역</u>이다.



- 쓰레기값?(garbage value)

만약 초기화단계를 거치지 않았다면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다. 이러한 값을 우리는 쓰레기값이라 부른다.



- Reference error(참조에러)

: **선언되지 않은 식별자에 접근 시 발생하는 에러**로, 엔진은 해당 식별자를 인식하여 특정메모리 공간에 할당된 값을 참조하려고 하나 자바스크립트 엔진이 등록된 식별자를 찾을 수 없어서 발생한다.

<br>

### 호이스팅

<hr></hr>

- 호이스팅이란?

hoisting은 끌어올리다라는 사전적의미를 지닌다.

호이스팅이란 인터프리터 언어인 자바스크립트의 특성을 무시한 것처럼 변수를 참조 후에 선언하였으나 마치 이전에 선언한 것처럼 `선언이 위로 끌어올려지는 것과 같은 현상`을 말한다.



- 호이스팅이 발생하는 이유

자바스크립트 엔진은 코드를 한줄 씩 순차적으로 실행하기에 앞서 **평가**라는 과정을 거치게 되는데, 이러한 평가 과정에서 변수선언문/ 함수선언문을 비롯한 모든 <u>선언문</u>들을 코드에서 찾아내어 **"먼저"** 실행한다.

이후 먼저 실행한 모든 선언문들을 제외하고 나머지 코드를 한줄씩 순차적으로 **실행** 한다.

이렇게 선언문을 가장 먼저 실행하는 자바스크립트의 특성 때문에 선언문의 위치와 관계없이 호이스팅 현상이 발생한다.
