# 전역변수의 문제점

- Toc

1. [변수의 생명주기](#변수의-생명주기)

2. [전역변수의 문제](#전역변수의-문제)

3. [전역변수 사용 억제방법](#전역변수-사용-억제방법)

   3-1.[즉시 실행함수](#즉시-실행함수)

   3-2.[네임 스페이스 객체](#네임-스페이스-객체)

   3-3.[모듈패턴](#모듈패턴)

   3-4.[ES6 모듈](#ES6-모듈)

<br>

<br>

## 변수의 생명주기

### 지역변수의 생명주기

- 변수를 선언한다 = 생성.

- 할당한다 = 값을 갖는다.

- 변수의 유효범위 = 범위 밖에서는 소멸. (유효하지 않음.)

이렇게 변수는 생성되고 소멸되는 생성주기가 있다. 만약 그렇지 않다면 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유할 것이다.

전역변수의 경우 생명주기는 애플리케이션의 생명주기와 같다. (쭉 살아있음.) 하지만 함수 내부에서 선언된 **지역변수**는 함수가 **호출**되면 생성되고 함수가 종료되면 소멸된다.

```javascript
function foo() {
  var x = 'local';
  console.log(x); // local
  return x;
}

foo();
console.log(x); // ReferenceError: x is not defined
```

위 예제에서 지역변수 x는 foo함수가 호출/`foo()`/ 되기 전까지는 생성되지 않는다. 

앞서 호이스팅에서 자바스크립트 엔진은 런타임 이전에 '평가'라는 단계에서 각 선언문들을 먼저 읽어드려 실행한다고 하였었다. 하지만 이 설명이 함수 내부에 선언된 변수까지 아우르는 것은 아니다. 엄밀히 말하면 런타임 이전에 실행되는 선언문은 전역변수, 함수에 한정된다.

함수 내부에서 선언한 변수는 함수가 호출된 직후 함수 몸체의 다른 코드가 실행되기 이전에 먼저 실행된다.

이것을 순서화 하면 다음과 같다.

1. 런타임 이전(전역선언문 실행)
2. 런타임
3. 함수 호출 직후(지역선언문 실행)
4. 함수 몸체 내 다른 코드들 순차적 실행

<br>

다음은 함수 내부에서 문들이 실행되는 과정을 도식화 한 것이다.

![image](https://user-images.githubusercontent.com/62285872/80676582-0c38f700-8af2-11ea-9197-4e831ce1ad9d.png)	

변수는 가장먼저 선언되어 생성된 후 함수의 호출이 끝나면 소멸된다. 때문에 **지역변수의 생명주기는 함수의 생명주기와 같다.**

> 호이스팅
>
> - 전역변수의 호이스팅
>
> 전역변수의 선언이 전역 스코프의 선두로 끌어올려진 것처럼 동작.
>
> - 지역변수의 호이스팅
>
> 지역변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작.
>
> 즉 호이스팅을 정리하자면 '변수선인이 **스코프**의 선두로 끌어 올려진 것처럼 동작하는 것' 이라고 할 수 있겠다.

<br>

### 전역변수의 생명주기

함수와 다르게 전역 코드는 명시적 호출이 없어도 실행된다. 다시 말해 전역코드는 함수호출과 같이 특별한 진입점(entry point)이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다.

> 진입점? (entry point)
>
> C나 Java로 작성된 코드를 실행하면 가장먼저 main 함수가 호출된다. 이 main 함수는 프로그램이 시작되는 지점이므로 이를 '진입점 또는 시작점' 이라고 한다.

- 함수와 전역코드의 종료시점

함수는 함수 몸체의 마지막 문 또는 반환문이 실행되면 종료된다. 하지만 전역코드의 경우 **더 이상 실행할 문이 없을 때** 종료된다.

var 키워드로 선언한 **전연벽수**는 **전역객체의 프로퍼티**가 된다. 때문에 지역변수가 함수의 생명주기와 일치하는 것처럼 **전역변수의 생명주기와 전역 객체의 생명주기가 일치한다.**

> 전역객체? (global object)
>
> 전역객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이다. 전역객체는 client side 환경(브라우저)에서는 **window**를, server side 환경(Node.js)에서는 **global** 객체를 의미한다.
>
> 전역객체는 표준 빌트인 객체(Object, String, Number, Function, Array 등..)들과 환경에 따른 호스트 객체(클라이언트 Web API 또는 Node.js의 호스트 API) 그리고 var 키워드로 선언한 전역변수와 전역함수를 **프로퍼티로 갖는다.**

![image](https://user-images.githubusercontent.com/62285872/80678210-71dab280-8af5-11ea-8d7d-e2c956353b0b.png)	

<br>

## 전역변수의 문제

- 암묵적 결합

전역변수를 선언한 의도는 전역, 즉 코드 어디에서든지 전역변수를 사용하겠다는 것이다. 이는 모든 코드가 전역변수를 참조하고 변경할 수 있는 **암묵적 결합**을 허용하는 것이다. 변수의 유효범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 **변경**될 수 이는 위험성도 높아진다.

- 긴 생명주기

전역변수는 생명주기가 길다. 따라서 메모리 리소스도 오랜기간 소비한다. 또한 전역변수으 상태를 변경할 수 있는 시간도 길고, 모든함수가 참조할 수 있기 때문에 상태를 변경할 기회도 많다.

또한, var 키워드는 변수의 중복선언이 가능하기 때문에 생명주기가 긴 전역변수는 변수 이름이 중복될 가능성이 있다. 변수이름이 중복되면 의도치 않은 재할당이 이루어 질 수도 있다.

- 느린 검색속도

앞서 스코프에서 자바스크립트 엔진은 변수를 참조할 때 스코프 체인을 통해 '변수를 참조하는 코드'의 스코프에서 시작하여 상위스코프 방향으로 이동하며 검색을 한다고 하였었다.

즉 전역변수는 스코프 체인 상 가장 **마지막**에 검색이 되며 때문에 가장 느린 검색속도를 가진다.

- 네임 스페이스 오염

자바스크립트의 가장 큰 문제점 중 각각 **분리**되어 존재하는 파일을 같은 문서에 불러올 경우 하나의 전역스코프를 **공유**한다는 것이다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.

<br>

## 전역변수 사용 억제방법

지금까지 설명하였던 이유들로 인해 전역변수의 무분별한 사용은 위험하다는 것을 느낀다. 그렇기 때문에 전역변수를 반드시 사용하여야 할 이유가 없다면 **지역변수를 사용해야 한다.** 변수의 생명주기는 짧은수록 좋다. (= 스코프는 좁을수록 좋다.)

다음은 전역변수의 사용을 억제할 수 있는 몇가지 방법이다.

- 즉시 실행함수로 변수래핑.
- 네임 스페이스 객체를 통한 변수추가.
- 모듈패턴
- ES6 모듈

<br>

### 즉시 실행함수

함수의 정의와 호출이 동시에 진행되는 즉시 실행함수는 단 **한번만** 호출된다. 모든 코드를 즉시실행 함수로 감싼다면 각 변수는 해당 함수 내에서만 유효한 스코프를 가진 지역변수가 된다.

```javascript
(function () {
  var foo = 10; // 즉시 실행 함수의 지역 변수
  // ...
}());

console.log(foo); // ReferenceError: foo is not defined
```

<br>

### 네임 스페이스 객체

전역에 **네임 스페이스**(Namespace) 역할을 담당할 객체를 생성하고 전역변수처럼 사용하고 싶은 변수를 **프로퍼티로 추가**하는 방법이다.

```javascript
// 네임스페이스 객체에 변수를 프로퍼티로 추가
var MYAPP = {};

MYAPP.name = 'Lee';

console.log(MYAPP.name); // Lee

// 네임스페이스 객체에 또 다른 네임스페이 객체를 프로퍼티로 추가
var MYAPP = {};

MYAPP.person = {
  name: 'Lee',
  address: 'Seoul'
};

console.log(MYAPP.person.name); // Lee
```

<br>

### 모듈패턴

관련이 있는 변수와 함수를 모아 **즉시 실행함수로 감싸** 하나의 모듈로 만드는 방식이다. 모듈패턴은 클로저를 기반으로 동작한다.(클로저가 뭐지? 나중에 배울것이다..)

모듈패턴은 전역변수의 억제는 물론 캡슐화까지 가능하다.

> 캡슐화란?
>
> 캡슐화는 외부에 공개될 필요가 없는 정보를 외부에 노출시키지 않고 숨기는 것을 말하며 정보은닉이라고도 부른다.
>
> Java의 경우 클래스를 구성하는 멤버에 대하여 publice, private, protected 등의 접근제한자를 사용해 공개범위를 한정한다. public으로 선언된 데이터 또는 메소드는 외부에서 접근이 가능하지만 private으로 선언된 경우는 외부에서 접근할 수 없고 내부에서만 사용된다. 이것은 클래스 외부에는 제한된 접근권한을 제공하며 원하지 않는 외부의 접근에 대해서 내부를 보호하는 기능을 한다.

```javascript
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

위 예제의 즉시 실행 함수는 **객체를 반환**한다. 이 객체에는 외부에 **노출**하고 싶은 변수나 함수를 담아 반환한다. 이때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버(public menber)이다. 외부로 노출하고 싶지 않은 변수나 함수는 **반환하는 객체에 추가하지 않으면** 외부에서 접근할 수 없는 **프라이빗 멤버**(private member)가 된다.

<br>

### ES6 모듈

전역변수의 남발을 억제하기 위해 ES6에서 도입된 모듈을 사용하기도 한다. 모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상) 에서 ES6모듈의 사용이 가능하다.

script 태그에 **type='mudule'** attribute를 추가하면 로드된 자바스크립트 파일은 모듈로써 동작한다. 모듈의 파일 확장자는 **mjs**를 권장한다.

```javascript
<script type="module" src="lee.mjs"></script>
<script type="module" src="wooseong.mjs"></script>
```

IE를 포함한 구형 브라우저에서는 ES6 모듈이 동작하지 않으며 브라우저의 ES6모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 **Webpack** 등의 모듈 번들러를 사용하는 것이 일반적이다.