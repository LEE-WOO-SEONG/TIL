# scope

- Toc

1. [스코프란?](#스코프scope란)

2. [스코프의 종류](#스코프의-종류)

3. [스코프 체인](#스코프-체인)
4. [함수레벨 스코프](#함수레벨-스코프)
5. [렉시컬 스코프](#렉시컬-스코프)



<br>

<br>

## 스코프(scope)란?

- 스코프의 사전적 정의

1. (무엇을 하거나 이룰 수 있는) 기회
2. **(주제조직활동 등이 다루는) 범위 ** -> 자바스크립트에서 스코프의 의미
3. 샅샅이 살피다

<br>
스코프란 특정 변수나 함수가 유효한 **범위**를 뜻한다. 

```javascript
function add(x, y) {
  console.log(x, y); // 2 5
  return x + y;
}

add(2, 5);         // 2 5

console.log(x, y); // ReferenceError: x is not defined
```

함수에서 매개변수(x, y)는 함수 몸체 내부에서만 참조가 가능하다. 즉, 매개변수가 유효한 범위는 함수몸체에만 한정되며 따라서 매개변수의 스코프는 함수몸체가 되는 것이다.

함수 내부에서만 사용이 가능한 매개 변수와는 달리, 일반변수는 전역 / 코드블럭 내부/ 함수내부 모두에서 사용이 가능하다. 하지만 자신이 선언된 위치에 의해 자신이 유효한 스코프 즉, **다른코드가 변수 자신을 참조할 수 있는범위** 가 결정된다.

변수 뿐만 아니라 모든 식별자가 그렇다. 다시 말해, **모든 식별자**(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프(Scope, 유효범위)라 한다. **즉, 스코프는 식별자가 유효한 범위를 말한다.**

```javascript
var x = 'global';

function foo() {
  var x = 'local';
  console.log(x); // 'local'
}

foo();         

console.log(x); // 'global'
```

위 예제에서 함수 내부에 선언된 변수 `x`와 함수외부에 선언된 변수 `x`는 다른 값을 가진다. 

그 이유는 각자의 변수가 유효한 '스코프'가 다르기 때문이다. 함수 외부에 선언된 변수는 어디서든지 참조가 가능하다. 스코프가 전역인 것이다. 하지만 함수 내부에 선언된 변수는 함수 내부에서만 참조가 가능하다. 스코프가 함수 몸체인 것이다.

![image](https://user-images.githubusercontent.com/62285872/80668873-e9044c80-8add-11ea-8b28-28d405ad236a.png)

> 자바스크립트 엔진은 코드를 실행할 때, 코드의 문맥을 고려한다. 코드가 어디서 실행되며 주변에 어떤 코드들이 있는지를 먼저 확인한다는 말이다.
>
> 그렇기 때문에 위 예제에서 함수내부에 선언된 변수는 코드문맥상 함수 내부에 갇혀있으므로 그 스코프가 결정되는 것이고 함수 외부에 선언된 변수는 아무런 제약이 없으니 전역에서 사용이 가능한 전역스코프가 되는 것이다.
>
> 코드가 어디서 실행되며 주변에 어떤 코드들이 있는지를 **환경**이라고 부른다. 코드의 **문맥**은 이러한 환경들로 이루어진다. 이를 구현한 것이 **실행 컨텍스트**이며 모든 코드는 실행 컨텍스트에서 평가되고 실행된다. 실행컨텍스트에 대해서는 추후에 다루기로 한다.

<br>

- var 키워드로 선언한 변수의 중복선언

var 키워드로 선언된 변수는 **같은 스코프** 내에서 중복선언이 **허용**된다. 이는 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다.

```javascript
function foo() {
  var x = 1;
  console.log(x); // 1
  var x = 2;  // 함수 스코프 내에서 중복선언이 가능.
  console.log(x); // 2 
}
foo();
```

- let / const 키워드로 선언한 변수의 중복선언

var와는 다르게 let / const 키워드로 선언된 변수는 같은 스코프내에서 중복선언을 **허용하지 않는다.**

```javascript
function bar() {
  let x = 1;
  console.log(x);  // 1
  let x = 2; // SyntaxError: Identifier 'x' has already been declared
}
bar();
```

<br>

## 스코프의 종류

코드는 전역(global) 과 지역(local)으로 구분할 수 있다.

| 구분 | 설명                  | 스코프     | 변수     |
| ---- | --------------------- | ---------- | -------- |
| 전역 | 코드의 가장 바깥 영역 | 전역스코프 | 전역변수 |
| 지역 | 함수몸체 내부         | 지역스코프 | 지역변수 |

변수는 자신이 **선언된 위치**(전역 / 지역)에 의해 자신이 유효한 범위인 **스코프**가 결정된다. 즉, 전역에서 선언된 변수는 전역스코프를 가지며 지역에서 선언된 변수는 지역스코프를 가진다.

![image](https://user-images.githubusercontent.com/62285872/80669806-426d7b00-8ae0-11ea-9bd2-b82f134e2d58.png)	

전역 스코프를 갖는 전역변수는 어디서든지 해당 변수의 참조가 가능하다. 반대로 지역변수는 자신의 지역스코프와 하위 지역스코프 에서만 유효하다.

<br>

## 스코프 체인

위 예제에서의 스코프 체인은 다음과 같다.

![image](https://user-images.githubusercontent.com/62285872/80670200-3f26bf00-8ae1-11ea-9e1f-0e23fe81e2dd.png)	

모든 스코프는 계층적 구조로 연결되어 있으며 모든 지역스코프의 최상위 스코프는 전역 스코프이다. 이렇게 스코프가 **계층적**으로 연결된 것을 **스코프 체인**(scope chain)이라 부른다.

위 그림에서 스코프 체인은 최상위 스코프인 전역스코프 - 전역에서 선언된 outer 함수의 지역스코프 - outer 함수 내부에 선언된 inner 함수의 지역스코프로 이루어 진다.

자바스크립트 엔진은 변수를 참조할 때 스코프 체인을 통해 **변수를 참조하는 코드의 스코프에서 '시작'하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.**

그렇기 때문에 하위 체인에 선언된 변수를 상위 체인에서 참조할 수 없으며 하위체인에서는 상위체인에서 선언된 변수를 참조할 수가 있게 되는 것이다.

스코프 체인은 물리적인 실체로 존재한다. 자바스크립트 엔진은 코드를 실행하기 앞서 위 그림과 유사한 자료구조(렉시컬 환경)를 실제로 생성한다.

> 렉시컬 환경? (Lexical environment)
>
> 스코프 체인은 실행컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다. 전역 렉시컬 환경은 코드가 로드되면 곧바로 생성되고 함수의 렉시컬 환경은 함수가 호출되면 곧바로 생성된다.

변수선언이 실행되면 변수 식별자가 이 자료구조(렉시컬 환경)에 등록되고, 변수의 할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 값을 변경한다. 변수의 검색 또한 이 자료구조 상에서 이루어 진다.

<br>

### 스코프 체인에 의한 변수검색

위 예제(그림 12-1)의 ④, ⑤, ⑥을 살펴보자. 이를 통해 자바스크립트 엔진이 스코프 체인을 통해 어떻게 변수를 찾아내는지 이해할 수 있다.

④ 변수 x를 참조하는 코드의 스코프인 inner 함수의 지역 스코프에서 변수 x가 선언되었는지 검색한다. 함수 inner 내에는 선언된 변수 x가 존재한다. 따라서 검색된 변수를 참조하고 검색을 **종료**한다.

⑤ 변수 y를 참조하는 코드의 스코프인 inner 함수의 지역 스코프에서 변수 y가 선언되었는지 검색한다. 함수 inner 내에는 변수 y의 선언이 존재하지 않으므로 상위 스코프인 함수 outer의 지역 스코프로 이동한다. 함수 outer 내에도 변수 y의 선언이 존재하지 않으므로 또 다시 상위 스코프인 전역 스코프로 이동한다. 전역 스코프에는 변수 y의 선언이 존재한다. 따라서 검색된 변수를 참조하고 검색을 **종료**한다.

⑥ 변수 z를 참조하는 코드의 스코프인 inner 함수의 지역 스코프에서 변수 z가 선언되었는지 검색한다. 함수 inner 내에는 변수 z의 선언이 존재하지 않으므로 상위 스코프인 함수 outer의 지역 스코프로 이동한다. 함수 outer 내에는 변수 z의 선언이 존재한다. 따라서 검색된 변수를 참조하고 검색을 **종료**한다.

이처럼 자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 절대 하위 스코프로 내려가면 식별자를 검색하는 일은 없다. 이는 **상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다**는 것을 의미한다.

스코프 체인으로 연결된 스코프의 계층적 구조는 부자 관계로 이루어진 **상속**(Inheritance)과 유사하다. 상속을 통해 부모의 자산을 자식이 자유롭게 사용할 수 있지만 자식의 자산을 부모가 사용할 수는 없다. 스코프 체인도 마찬가지 개념이다.

<br>

### 스코프 체인에 의한 함수검색

함수 선언문으로 함수를 정의하면 자바스크립트 엔진에 의해 런타임 이전에 함수 객체가 먼저 생성되고 암묵적으로 함수이름과 동일한 이름의 **식별자**를 선언 후 함수객체를 할당한다.

앞서 스코프를 **식별자가 유효한 범위**라고 정의하였다. 함수 또한 암묵적으로 선언된 식별자를 갖기 때문에 스코프를 갖는다고 할 수 있다.

함수에서의 스코프 체인에 의한 검색방식은 변수에서와 동일하다.

```javascript
// 전역 함수
function foo() {
  console.log('global function foo');
}

function bar() {
  // 중첩 함수
  function foo() {
    console.log('local function foo');
  }

  foo();   // 중첩함수 foo 호출
}

bar();  // 'local function foo'
foo();  // 'global function foo'
```

먼저 bar 함수를 호출하게 되면 내부에 중첩함수인 foo를 호출한다. 이 때 자바스크립트 엔진은 foo라는 식별자를 가진 함수를 호출하는 코드의 스코프인 중첩함수 foo의 지역스코프에서 foo라는 식별자를 가진 함수가 있는지 검색한다. 해당 스코프 내에 해당 식별자를 지닌 함수가 존재하므로 해당 함수를 참조하고 검색을 종료한다.

결과값 => 'local function foo'

또, foo 함수를 호출하게 되면  foo라는 식별자를 가진 함수를 호출하는 코드의 스코프인 전역스코프에서 foo라는 식별자를 가진 함수가 있는지 검색하고, 해당 스코프 내에 해당 식별자를 지닌 함수가 존재하므로 해당함수를 참조하고 검색을 종료한다.

결과값 => 'global function foo'

<br>

## 함수레벨 스코프

지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다고 했다. 이는 **코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다**는 의미이다.

C나 Java 등 대부분의 프로그래밍 언어는 함수 몸체 만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만든다. 이러한 특성을 **블록 레벨 스코프(Block level scope)**라 한다. 하지만 **var 키워드로 선언된 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다.** 이러한 특성을 **함수 레벨 스코프(Function level scope)**라 한다. 

```javascript
// 
var z = 1;
console.log(z);   // 1
{
  var z = 4;
  console.log(z); // 4
}

console.log(z);   // 4

//
var x = 1;

if (true) {
  var x = 10;
}

console.log(x); // 10
```

위 2가지 예제를 보면 코드블럭 내에 var 키워드로 선언한 변수에 할당된 값들이 해당 코드블록 바깥의 스코프에서도 유효한 것이 확인된다. 즉 var 키워드로 선언한 변수는 함수레벨 스코프를 가지므로 함수 바깥에서의 변수선은 모두 전역변수선언이라고 볼 수 있다.

```javascript
var i = 10;

for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```

> 이러한 현상은 for문의 조건문`()` 내에 선언된 변수에서도 똑같은 현상을 보이게 되므로 참고하도록 하자. 그렇기 때문에 조건문에서 사용한 변수인 `i`는 되도록 사용하지 않는 것이 좋겠다. 

<br>

## 렉시컬 스코프

함수에서 스코프를 결정하는 방식은 두가지가 있다.

1. 함수를 어디서 **호출** 했는지에 따른 스코프 결정 

   -> 동적 스코프(Dynamic scope)

2. 함수를 어디서 **정의** 했는지에 따른 스코프 결정 

   -> 렉시컬 스코프 (Lexical scope) / 정적 스코프 (Static scope) 

다음 예제를 보자.

```javascript
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

위 예제에서 

1번방식으로 함수의 상위 스코프를 결정한다면 bar의 상위 스코프는**함수 foo**와 **전역** 일 것이다. 

2번방식으로 함수의 상위스코프를 결정한다면 bar의 상위스코프는 **전역**일 것이다.

>  자바스크립트를 비롯한 대부분의 프로그래밍 언어는 2번방식인 렉시컬 스코프를 따른다. 그렇기 때문에 함수를 어디서 정의했는지에 따라 자신과 상위 스코프를 결정한다. 즉, 모든 함수는 정의는 평가되어 함수객체를 생성할 때, 자신이 정의된 스코프를 상위 스코프로써 기억한다.

렉시컬 스코프는 뒤에 배울 '클로저'와 깊은관계가 있다. 지금은 그렇다고만 생각하고 넘어가기로 하자. 아직 클로저에 대한 학습이 되어있지 않은 상태이므로...