

## 동기, 비동기 함수의 차이점

*한줄 답변: 코드의 순차적인 실행 vs 콜백에 전달된 코드를 나중에 실행*

동기 함수는 블로킹(blocking)이 발생하지만, 비동기 함수는 그렇지 않다.

동기 함수는 앞에 있는 코드의 실행이 완료되어야 다음으로 넘어간다. 실행 순서가 보장되지만, 어떤 코드의 실행 시간이 길어진다면 프로그램이 멈춘 것처럼 보이게 될 것이다.

비동기 함수는 보통 콜백 함수를 파라미터로 받고 실행 즉시 다음 라인에 있는 코드로 넘어간다. 콜백은 비동기 작업이 완료되고 콜 스택이 비었을 때 실행된다. 웹 서버로부터 데이터를 불러오거나 데이터베이스 쿼리를 실행하는 것 같은 무거운 작업은 비동기적으로 실행되어야 한다. 그래야 메인 스레드가 그 긴 작업 시간동안 멈추지 않고 진행될 수 있다. 브라우저에서 저런 작업을 비동기로 하지 않는다면 UI가 사용자의 입력에 반응하지 않고 멈춰버릴 것이다.

### 추가) 그렇다면 전달된 콜백을 나중에 실행하는 메커니즘에 대하여 설명 해 보시오.



## javascript 에서 this 바인딩에 대해서 설명 해 보시오.

자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다.

| 함수 호출 방식                                             | this 바인딩                                                  |
| :--------------------------------------------------------- | :----------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체                                                    |
| 메서드 호출                                                | 메서드를 호출한 객체                                         |
| 생성자 함수 호출                                           | 생성자 함수가 (미래에) 생성할 인스턴스                       |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 |

### 추가) 그렇다면 이벤트 핸들러를 프로퍼티 방식으로 dom 요소에 바인딩 시켰을 떄, 해당 핸들러 내부의 this가 가리키는 것은 무엇일까요?

핸들러를 바인딩한 dom 요소.

## javascript 에서 strict 모드를 사용하는 방법과 사용했을 때의 변화에 대해 설명해보시오.

```javascript
// 함수 혹은 전역의 가장 선두에 다음과 같이 적용.
`use strict`;
```

### 장점

- 의도하지 않은 전역 변수가 선언되지 못하도록 한다 (암묵적 전역)
- 삭제할 수 없는 속성(property)를 삭제하려고 시도하면 오류를 발생시킨다 (변수 함수 매개변수에 delete 연산자 사용 불가)
- 함수의 파라미터 이름은 서로 달라야 한다. (매개변수 이름의 중복 불가)
- 일반함수에서 ``this`` 는 undefined 이다.
- 함수의 매개변수에 전달된 인수를 재 할당하여 변경하여 arguments 객체에 반영되지 않는다.
- 몇몇 일반적인 코딩 실수를 잡아서 예외 처리(throw exception)시킨다 (예를 들어 전역 객체에 접근하려고 하는 것)
- 자바스크립트에서 개발자에게 혼란을 주거나, 잘못 만든 것으로 보이는 여러 기능의 사용을 금지한다

### 단점

- 못쓰게 되는 많은 기능들이 어떤 개발자에게는 필요한 기능일 수 있다
- `function.caller` 그리고 `function.arguments` 에 접근할 수 없다
- 서로 다른 strict mode로 작성된 코드를 연결했을 때 오류가 발생할 수 있다.



## LocalStorage, SessionStorage, Cookie의 차이점에 대하여 설명 해 주세요.

Web Storage(local, session)의 개념은 키/값 쌍으로 데이터를 저장하고 키를 기반으로 데이터를 조회하는 패턴이다.

### LocalStorage와 SessionStorage

Web Storage는 데이터의 지속성과 관련하여 두 가지 용도의 저장소를 제공한다.

우선 기본적으로 Web Storage는 쿠키와 마찬가지로 사이트의 도메인 단위로 접근이 제한된다. 예를 들어, A 도메인에서 저장한 데이터는 B 도메인에서 조회할 수 없다는 것이다. 이는 데이터의 보안 측면에서 당연하다.

### LocalStorage

- 저장한 데이터를 명시적으로 지우지 않는 이상 영구적으로 보관이 가능하다.
- 앞서 말한대로 도메인마다 별도로 로컬 스토로지가 생성된다. 
- Windows 전역 객체의 LocalStorage라는 컬렉션을 통해 저장과 조회가 이루어진다.
- 용량 10mb

### SessionStorage

- 브라우저를 종료하면 데이터가 삭제된다.
- SessionStorage는 windows 전역 객체의 sessionStorage라는 컬렉션을 통해 저장과 조회가 이루어진다.
- 용량 5mb

### cookie

- 매 서버요청시마다 header에 포함되어 요청됨.
- 용량이 4kb 갯수가 20개로 제한됨.
- 만료일자가 있음.

## 클로저란? 클로저가 갖는 장점에 대해 설명 해 보시오.

클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미한다.

바스크립트의 함수는 `이론상의 객체`인 [환경 레코드](https://tc39.es/ecma262/#sec-environment-records)의 프로퍼티인 `[Environment]]`를 이용해 자신이 어디서 만들어졌는지를 기억한다.

내부 함수의 생명주기가 더 길어야 되며 자유변수를 참조해야 함.

### 장점

- 전역 변수의 오염을 막을 수 있고, 변수 값을 은닉하여 사용할 수 있다.

