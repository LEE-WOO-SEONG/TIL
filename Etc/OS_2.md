# OS 2일차



## OS 

RTOS(RealTimeOS) - 실제 프로세싱의 시간을 정확히 알 수 있는 os

GPOS(GeneralPurposeOS) - 일반적 os



## 스케쥴링

스케쥴링이란 처리할 일들의 진행순서를 정하는 것을 일컫는다.

<br>

### FIFO 스케쥴러 (First In First Out)

- 배치처리 시스템으로 하나의 프로세스가 CPU를 처음부터 끝까지 연속적으로 사용한다.
- 프로세스 간 우선순위가 없이 하나의 프로세스를 쭉 실행하게되어 block 현상이 발생할 수 있다.
- FCFS(First Come First Served) 스케쥴러라고도 불린다.

<br>

### SJF (Short Job First)

- 프로세스 실행시간이 짧은 프로세스부터 먼저실행 하는 방식이다.
- FIFO와 마찬가지로 우선순위가 없기 때문에 대기중인 프로세스들은 block 현상이 발생할 수 있다.

### Round Robin 스케쥴러

- 프로세스간 우선순위를 두지 않고 순서대로 시간단위로 cpu를 할당하는 방식이다.
- 보통 시간단위는 10ms ~ 100ms 정도이며 해당 시간동안 수행된 프로세스는 준비 큐의 끝으로 밀려나게 된다.
- 문맥전환의 오버헤드가 큰 반면, 응답시간이 짧아지는 장점이 있어 실시간 시스템에 유리하다.

### 우선순위 기반 스케쥴러

- 정적 우선순위

프로세스 마다 우선순위를 미리 지정.

- 동적 우선순위

스케쥴러가 상황에 따라 우선순위를 동적으로 변경.



### 프로세스 상태 기반 스케쥴러 (멀티 프로그래밍)

1. Ready Queue (실행 대기 상태)
2. Running Queue (실행 중 상태)
3. Blocked Queue (특정 이벤트 발생 대기 상태)



- IO-bound : input <-> output에 걸리는 시간에 의해 computation이 결정되는 영역
- CPU-bound : I/O bound 이외의 영역

<br>

## 프로세스(Process)

### 프로세스 구조

- text : 프로그램의 실제 코드를 저장하는 공간

- data : 프로세스가 실행될 때 정의된 전역변수들을 저장

- stack : 함수내부의 지역변수 ,함수 들의 정보를 저장

- heap : 프로세스 런타임 중 동적으로 할당되는 변수들을 저장(함수 내에서 할당되는 변수 등등..)

  ![image](https://user-images.githubusercontent.com/62285872/86906015-dcd7e380-c14d-11ea-9173-5564f0acbb10.png)	



### PC (program counter)

다음 실행할 코드의 주소를 가리킨다.

일반적으로 해당 코드의 실행이 완료되면 실행한 코드의 주소값에 + 1을 하여 다음 주소값을 가리킨다.

시분할 프로그래밍에서 컨텍스트 스위칭 시 전환될 프로세스의 코드가 있는 주소값을 PC가 가리키게 되어 특정 프로세스를 실행할 수 있게 된다.

### SP (stack pointer)

프로세스 구조 중 stack의 최상단 주소를 나타낸다.

<br>

### 컨텍스트 스위칭 (context switching)

- CPU에 실행할 프로세스를 **교체**하는 기술

- CPU의 PC / SP의 정보를 특정 프로세스의 정보가 저장된 PCB의 PC, SP로 바꾸어 주면 해당 프로세스를 실행하게 된다.

> PCB (Process Control Block)?
>
> 특정 프로세스의 status / priority / pc, sp 등의 정보들을 저장하는 영역으로 프로세스가 실행중인 상태를 캡쳐, 구조화해서 저장(업데이트) 한다.

- 컨텍스트 스위칭의 세부동작
  1. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트하여 메인 메모리에 저장한다.
  2. 다음 실행할 프로세스의 PCB 정보(PC, SP)를 CPU의 레지스터에 넣고 실행한다.

<br>

### 프로세스간 커뮤니케이션(IPC) (Inter Process Communication)

컴퓨터의 성능을 높이기 위해 여러 프로세스를 만들어 동시에 실행하게 되었고, 하나의 프로세스는 다른 프로세스의 공간에 접근할 수 없으므로 프로세스간 통신 기법이 나오게 되었다.

프로세스의 3 ~ 4GB의 공간에는 커널에 접근할 수 있는 영역으로 설계되어있어 다른 프로세스들끼리 하나의 커널공간을 공유하여 프로세스간 통신이 가능하게 되었다.

ex) kernal 영역에 메모리 공간을 만들고 해당 공간을 변수처럼 사용하여 여러 프로세스간에 변수를 공유할 수 있게 되었음.

- 정리

![image](https://user-images.githubusercontent.com/62285872/86908842-23c7d800-c152-11ea-9383-d8a5fd341ae5.png)

<br>

## 스레드(Thread)

- 개념

  프로세스 내에 존재하는 실행의 흐름.

- 특징

  하나의 프로세스는 여러개의 스레드의 생성이 가능

  프로세스의 text, data, heap의 리소스를 공유할 수 있음. (stack은 각자의 영역을 공유) 

- 장점

  1. 사용자에 대한 응답성 향상에 기여.

     (하나의 thread는 작업을 담당하고 다른 하나의 thread는 사용자와의 커뮤니케이션을 담당하게 함)

  2. 리소스의 공유가 가능함.

     프로세스간 자원공유를 위해서는 IPC라는 번거러운 통신기법이 필요하는 것과 다르게 하나의 프로세스를 공유하므로 해당 프로세스의 리소스에 모두 접근이 가능하다.

- 단점

  여러개의 thread 중 하나의 thread에만 문제가 있어도 전체 프로세스에 영향을 주게된다.

- 스레드 동기화
  - 동기화 해결방법
    1. mutex : critical section에 하나의 thread 만이 작업이 가능함.
    2. semaphore : critical section에 접근할 수 있는 thread의 수를 제어.



- mutual exclusion
  - critical resource - 한 프로세스 안에서 스레드끼리 공유되는 자원
  - critical section - critical resouce를 접근하는 코드가 있는 영역



- deadlock (교착상태)

  : 무한 대기상태를 뜻하며, 두 개 이상의 서로 다른 작업이 해당 작업결과에 종속적으로 묶여있어 서로의 작업이 끝나기만을 기다리기 때문에 다음 단계로 진행하지 못하는 상태.



- starvation (기아상태)

  : 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태.

  > 교착상태는 여러 프로세스가 동일 자원 점유를 요청할 때 발생하며,
  >
  > 기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 연원히 자원 할당이 안되는 경우를 의미한다.





멀티 프로세스 vs 멀티 쓰레드??

