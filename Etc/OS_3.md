# OS 3일차



## 스케쥴링 알고리즘

### 선점형 스케쥴러(Preemptive Scheduling)

: 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있음.

### 비선점형 스케쥴러(Non-preemptive Scheduling)

: 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음.



### 인터럽트

CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술.

- 인터럽트가 필요한 이유
  1. I/O device와의 커뮤니케이션. (키보드, 마우스 입출력등등..)
  2. 예외상황 핸들링. (이벤트 처리 등.)

- 주요 인터럽트

  1. 계산하는 코드에서 0으로 나누는 코드 실행 시 (폴트: 해당 프로세스의 에러 발생 및 중지)
  2. 타이머 인터럽트 : Round-Robin 스케쥴러를 위해 필요
  3. 입출력(IO) 인터럽트

- 인터럽트 종류

  1. 내부 인터럽트(소프트웨어 인터럽트)
     - 주요 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
       1. 0으로 나눴을 때
       2. 사용자 모드에서 허용되지 않은 명령 또는 공간 접근 시
       3. 계산 결과가 Overflow/Underflow 날 때
  2. 외부 인터럽트(하드웨어 인터럽트)
     - 주로 하드웨어에서 발생되는 이벤트
       1. 전원 이상
       2. 기계 문제
       3. 키보드등 IO관련 이벤트
       4. Timer 이벤트

- 시스템 콜 인터럽트

  : 시스템 콜의 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어, CPU에게 실행시켜야 한다.

  - 시스템 콜 실제 코드

    : eax 레지스터에 시스템 콜 번호를 넣고,

      ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고

      소프트웨어 인터럽트 명령을 호출하면서 0x80 값을 넘겨줌



<br>

## 가상메모리

### 가상 메모리 (virtual memory)

각 프로세스는 이론적으로 4GB의 메모리 공간을 사용한다고 알려져 있는데, 모든 프로세스마다 충분한 메모리 공간을 할당하기에는 메모리 크기는 제한적이며, 실제로 프로세스에서 할당된 모든 메모리 공간을 사용하는 것은 아니다.

- 가상 메모리 기본 아이디어

  - 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸 때에만 물리주소로 바꿔 사용.

  - virtual address (가상주소) : 프로세스가 참조하는 주소 (보조 기억 장치에 저장)

  - physical address (물리주소) : 실제 메모리 주소 (주 기억장치 저장)

- MMU (Memory Management Unit)

  : CPU에 코드 실행 시 가상 주소 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환 해 주는 하드웨어 장치.

### 가상메모리의 필요 이유

1. 하나의 프로세스만 실행 가능한 시스템 (배치처리 시스템)
   - 프로그램을 메모리로 로드
   - 프로세스 실행
   - 프로세스 종료 (메모리 해제)
2. 여러 프로세스 동시 실행 시스템
   - 메모리 용량 부족 이슈
   - 프로세스 메모리 영역간의 침범 이슈

### 컴퓨터의 구성요소

1. CPU(Central Processor Unit)
   - 연산
   - 제어
2. Memory - 코드와 데이터를 저장하는 장치
   - 프로그램과 프로그램 수행에 필요한 데이터를 저장
   - 내부기억장치 (주 기억장치)
     - CPU 내 레지스터(register) 및 캐쉬(cache memory)
     - DRAM 등 메모리 (RAM, DDR4)
   - 외부 기억장치 (보조 기억장치)
     - SSD, HDD
3. IO device (입출력 장치)
   - 입력장치 : 마우스 / 키보드 / 터치패드 등
   - 출력장치: 모니터 / 프린터 / 스피커 등

> BUS
>
> - CPU, Memory, IO device를 연결 해 주는 장치
> - 개별적인 IO devices들을 연결해주고 데이터를 송수신 해주는 장치

<br>

## 페이징 시스템

### 페이징의 개념

- 크기가 동일한 페이지로 가상 주소공간과 이에 매칭하는 물리 주소공간을 관리
- 하드웨어 지원이 필요
- 리눅스에서는 4KB로 paging
- 페이지 번호를 기반으로 가상 주소/ 물리 주소 매핑정보를 기록, 사용
- 프로세스의 PCB에 Page Table 구조체를 가리키는 주소가 들어있음
- Page Table에는 가상주소와 물리주소간 매핑 정보가 있음.

### 페이징 시스템 구조

- page 또는 page frame : 고정된 크기의 block (4KB)

- paging system

  - 가상주소 v = (p, d)

    p: 가상 메모리 페이지

    d: p 안에서 참조하는 위치

### 페이지 테이블

- page table
  - 물리주소에 있는 페이지 번호와 해당 페이지의 첫 물리주소 정보를 매핑한 표
- paging system 동작
  - 해당 프로세스에서 특정 가상 주소를 엑세스 하려면
    1. 해당 프로세스의 page table에 해당 가상주소가 포함된 page 번호가 있는지 확인
    2. page 번호가 있으면 이 page가 매핑된 첫 물리주소를 알아내고 ( p' )
    3. p' + d 가 실제 물리주소가 된다.

### 페이징 시스템과 MMU

CPU는 가상 주소 접근 시, MMU 하드웨어 장치를 통해 물리메모리에 접근한다.

또한 프로세스 생성 시 page table 정보를 생성하여 PCB 등에서 해당 page table에 접근이 가능하고 관련정보는 물리 메모리에 적재.

프로세스 구동 시 해당 page table의 base 주소가 별도 레지스터에 저장 (CR3)

CPU가 가상주소 접근 시 MMU가 page table의 base 주소를 접근하여 물리주소를 가져온다.

### MMU와 TLB

- TLB(Translation Lookaside Buffer) : 페이지 정보 캐쉬를 일컫는 용어로 기존에 한번 이상 접근한 페이지 테이블은 해당 테이블의 정보를 가리키는 주소를 저장 해 놓았다가 동일한 페이지 테이블에 다시 접근해야 할 시 해당 정보를 바로 이용하여 물리 메모리 주소에 접근한다.

### Demanding paging

: 프로세스의 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재하는 방식.

<-> anticipatory paging, prepaging : 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념.

### page fault

: 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트

page fault가 일어나면 운영체제가 해당 페이지를 물리 메모리에 적재한다.

![image](https://user-images.githubusercontent.com/62285872/87314258-eef6bf00-c55d-11ea-9ea8-a4ff3347804d.png)

### 페이지 교체 정책 (page replacement policy)

: 운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리메모리가 다 차있는 경우 기존 페이지 중 하나를 물리 메모리에서 저장매체로 내리고, 새로운 페이지를 해당 물리메모리 공간에 올리는 방식.

- 페이지 교체 알고리즘
  1. FIFO : first in first out => 가장 먼저 들어온 페이지를 내리는 방식.
  2. OPT : 최적 페이지 교체 알고리즘 (optimal replacment algorithm) => 앞으로 가장 오랫동안 사용하지 않을 페이지를 내리는 방식으로 일반 OS에서는 구현이 불가능.
  3. LRU : least recently used => 가장 오래전에 사용된 페이지를 교체하는 방식.
  4. LFU : least frequently used => 가장 적게 사용된 페이지를 교체하는 방식. (메모리는 가장 최근에 사용된 메모리 공간과 가까운 메모리 공간을 사용할 확률이 높은 지역성을 가짐.)
  5. NUR : not used recently : LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 방법으로 각 페이지마다 참조비트(R)와 수정비트(M)을 둔다.(R, M)
     - (0, 0) / (0, 1) / (1, 0) / (1, 1) 순으로 페이지 교체

### 스레싱(Thrashing)

: 반복적으로 페이지 폴트가 발생하여 과도하게 페이지의 교체 작업이 일어나 실제로는 아무일도 하지 못하는 상황.