# JS 용어정리



#### callback 함수란?

javascript에서는 callback 함수는 **다른 함수의 매개변수로 함수를 전달하고**, 어떠한 이벤트가 발생한 후 매개변수로 전달한 함수가 **다시 호출되는 것**을 의미합니다.

callback은 쉽게 말하자면 어떤 일을 다른 객체에게 시키고, 그 일이 끝나는 것은 기다리지 않고 끝나고 부를 때까지 다른 일을 하는 것을 말합니다.

- callback 함수를 쓰는 이유

만약 node.js를 쓰면서 콜백을 받아야 하는 상황에 callback 함수를 사용하지 않는다면 콜백 함수의 과정이 끝나기 전에 다음 프로세스가 진행될 수 있습니다.

그것을 막기 위해 차례대로 수행하기 위해 callback 함수를 사용해야 합니다.



#### prototype

: prototype의 사전적 정의는 시제품이 나오기전 제품의 **원형** 또는 시스템의 **초기모델**을 뜻한다.



자바스크립트에서 prototype은 이러한 의미에 걸맞게 **자신을 만들어낸 객체의 원형**을 말한다.

- proto - 자신을 만들어낸 객체의 <u>원형</u>과 연결된 속성이다.

- constructor - 생성자로써, 자신을 만들어낸 <u>객체</u>와 연결된 속성이다.

- prototype - <u>자신을 원형으로</u> 만들어진 새로운 객체들과 연결된 속성이다.

출처: https://mygumi.tistory.com/312 [마이구미의 HelloWorld]



### 파라미터란?

: 함수에서 결과계산을 위해 넣어주는 값?

```
function print(a,b) {
return a+b;
}
```

-> 여기서 a,b 는 파라미터이다.

### 인자란?

: 주어진 함수로 특정결과값을 도출하고 싶을 때 넣어주는 값.

```
function print(a,b) {
return a+b;
}

console.log(print(1,2)) -> 3
```

-> 여기서 print내에 1,2 는 인자이다.



#### const, let, var 차이점



- 변수선언 방식

var : 변수 재선언이 가능하다.

let : 변수 재선언은 불가능하나, 변수 재 할당은 가능하다.

const : 변수 재선언 및 변수 재 할당 모두 불가하다.



- hoisting 문제

###### hoisting 이란?

호이스팅(Hoisting)이란, var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성.

자바스크립트는 ES6에서 도입된 let, const를 포함하여 모든 선언(var, let, const, function, function*, class)을 호이스팅한다.



변수는 `선언 단계` > `초기화 단계` > `할당 단계` 에 걸쳐 생성되는데 `var` 로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 하지만, `let` 로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.

그렇기 떄문에 `var`로 변수 선언 시 호이스팅 문제가 발생하게 된다.



- 결론 

 상기 변수선언 방식과 hoisting 문제로 볼 때 `var`보다는 `let`과 `const`를 사용도록 하며

재할당이 필요한 경우가 아니라면 가급적 `const`를 사용하여 변수를 선언하는 것이 좋다.



#### compile vs interpret 

- compile language

> 실행시점 : 런타임 이전
>
> 번역속도 : 느림 (소스코드 전체를 통으로 번역)
>
> 실행속도 : 빠름 (최조 번역시간은 느리나 한번 번역을 마치면 파일형태로 저장되기 때문에 바로실행이 가능.)
>
> 메모리할당 o    (번역한 코드를 바이너리 형태의 파일로 저장해 놓음.)
>
> 운영체제에 종속적이다. (cpu마다 명령어 셋이 다를 수 있어 다른 cpu에서 사용시 새로 컴파일 필요함.)



- interpret language

> 실행시점: 런타임 이후
>
> 번역속도 : 빠름 (한줄씩 번역 후 실시간으로 실행)
>
> 실행속도 : 느림 (번역과 실행이 실시간으로 이루어지므로)
>
> 메모리 할당 x (실시간 번역 및 실행으로 컴파일러처럼 따로 파일을 저장하지 않음.)
>
> 운영체제에 종속적이지 않음. (운영체제에 맞는 실시간 번역 및 실행으로 같은 소스코드를 다른 cpu에서도 동일하게 실행이 가능하다.)